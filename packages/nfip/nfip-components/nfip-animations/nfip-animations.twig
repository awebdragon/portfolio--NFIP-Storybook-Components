<div class="grid-container">
  <h1>Animations</h1>
  <p>This landing page hosts information about how to set up the animations library and some useful links for learning how to use the animations.</p>

  <h2 class="padding-top-3">AOS</h2>
  <p>AOS is already on the Floodsmart sites, so there shouldn't be any installation requirements to build the custom animations. AOS animations can be used in the Layout Builder at section and block levels, and in Source view HTML if more granularity is needed.</p>

  <p>For a list of attributes, see this: <a href="https://github.com/michalsnik/aos?tab=readme-ov-file#2-set-animation-using-data-aos-attribute">https://github.com/michalsnik/aos?tab=readme-ov-file#2-set-animation-using-data-aos-attribute</a>. This page is also a good resource for how to write the data attributes if you're writing in source HTML.</p>

  <p>For a list of all animations and other attribute values available in the library, view here: <a href="https://github.com/michalsnik/aos#animations">https://github.com/michalsnik/aos#animations</a></p>

  {# <p>This is the library that the Layout Builder uses to add animation effect to sections and blocks. We may be able to use this library to come up with classes and other parameters the content manager can select to reduce the number of layouts generated just for animation differences. If not, then this library was added to storybook so that the effects of the Layout Builder could be represented in page demos.</p>

  <p>AOS uses sets of custom attributes rather than class names, so using it may be tricky. All attributes begin with "data-aos", followed by the unique tail end that tells AOS what to implement, such as which animation to use, delay, easy, use only once, etc.</p>
    
  <p>But, we can add several fields for adjusting AOS, and it may help us keep the working area clean if we make it a separate tab from the content fields. Otherwise, if we're adding AOS attributes to the HTML directly, then this isn't a problem.</p>

  <p>Remember to initialize AOS after the dom content has loaded. If JQuery isn't available, one solution in plain JS might look like this:</p>

  <code>
    <pre class="padding-2 bg-base-lightest" style="white-space: pre-wrap; word-wrap: break-word;">
      document.addEventListener( "DOMContentLoaded", function(){
        AOS.init();
      } );</pre>
  </code>

  <p>To see how all the attributes should be written, see this: https://github.com/michalsnik/aos?tab=readme-ov-file#2-set-animation-using-data-aos-attribute</p>

  <p>For a list of all animations and other attribute values available in the library, view here: https://github.com/michalsnik/aos#animations</p>

  <p>To help us determine what fields to add for AOS animation, here are the AOS attributes that we use in our animations library:</p>

  <ul>
    <li>Animation name, i.e. data-aos="<strong>slide-left</strong>"
      <ul>
        <li>This one is variable. Perhaps we could use a taxonomy to add and maintain these, including any custom ones we might make.</li>
      </ul>
    </li>
    <li>Easing, i.e. data-aos-easing="<strong>ease-out</strong>"
      <ul>
        <li>The list is long, but it's a finite list with no customization. A dropdown of fixed values might be preferable here.</li>
      </ul>
    </li>
    <li>Duration, i.e. data-aos-duration="<strong>1100</strong>"
      <ul>
        <li>This is a number, measuring milliseconds, meaning we can set anything we want. A number field would be most appropriate. A note from the AOS library creator: "Duration and delay accept values from 50 to 3000, with step 50ms". We'd need to add more values ourselves if we want them, but we should be mindful not to go over 5000 (5 seconds).</li>
      </ul>
    </li>
    <li>Delay, i.e. data-aos-delay="<strong>500</strong>"
      <ul>
        <li>This is a number, measuring milliseconds, meaning we can set anything we want. A number field would be most appropriate. A note from the AOS library creator: "Duration and delay accept values from 50 to 3000, with step 50ms"..</li>
        <li>This isn't used in any of the example animations, but if we end up needing to add fields to a component/paragraph to animate it, we want to make sure to add a field for this attribute.</li>
      </ul>
    </li>
  </ul> #}

  <h2 class="padding-top-3">GSAP</h2>
  <p>GSAP requires hand-coding the animations, even for simple stuff, so it's best to use only when other prebuilt solutions won't work.</p>

  <p>First, we need to register the plugins we're using.</p> 

  <code>
    <pre class="padding-2 bg-base-lightest" style="white-space: pre-wrap; word-wrap: break-word;">gsap.registerPlugin(ScrollTrigger,TextPlugin);</pre>
  </code>
  
  <p>Note that Observer is included in ScrollTrigger, so if we ever need it, we already have it.</p>

  <p>For the actual animation code, we'll want to make sure that the document content loads before GSAP can attempt to do anything. That could look something like this:</p>

  <code>
    <pre class="padding-2 bg-base-lightest" style="white-space: pre-wrap; word-wrap: break-word;">
      document.addEventListener( "DOMContentLoaded", function(){
        // code stuff and things
      } );</pre>
  </code>

  <p>Then, we want to set up our defaults so we don't have to set them over and over again. Since this is animation code:</p>

  <code>
    <pre class="padding-2 bg-base-lightest" style="white-space: pre-wrap; word-wrap: break-word;">document.addEventListener( "DOMContentLoaded", function(){
      // set defaults that can be turned off by using "inherit:false" or by overriding inside the tween
      gsap.defaults({
        ease: "power2.out", // ease out
        duration: 1,
      });

      // when "scrub" is false (the default state), scroll trigger should replay the animation if the user scrolls up, then scrolls back down to bring the element in view again. This mimics how AOS scroll animations work. 
      ScrollTrigger.defaults({
        normalizeScroll: true,
        toggleActions: "restart none none none",
        once: false,
      });

      More stuff and things...</pre>
  </code>

  <p>Then, we need to do some things to set our animations up. The Basic and Section animations are designed to be <em>repeatable</em>, but GSAP, and especially ScrollTrigger, requires our JS to be called in the same order the elements appear in the DOM. This is a problem if we're turning our animated sections into repeatable paragraphs that we can place in any order on the page.</p>

  <p>So, we implement a parent class name that's used across all instances of GSAP animation: "flsm-gsap". We then target that class, and run a forEach loop that checks for additional class names that indicate which animation to apply. This means that the JS is called in the order the animated elements appear in the DOM.</p>

  <p>Here is the complete forEach loop for all the animations demo'd on the Section and Parallax Animations page:</p>
  <code>
<pre class="padding-2 bg-base-lightest" style="white-space: pre-wrap; word-wrap: break-word;">// create the base For Each loop that will locate animation instances. This helps each animation load in the correct order.
  const flsmGSAPMainArray = gsap.utils.toArray('.flsm-gsap');
  flsmGSAPMainArray.forEach( element => {
    if ( element.classList.contains('flsm-parallax--slide-up-bottom') ) {
      // this is a section containing multiple sub-sections. "element" is selecting the top-most parent container here
      createSlideUpBottomAnimation(element);
    } else if ( element.classList.contains('flsm-parallax--background-zoom') ) {
      // this is a section containing multiple sub-sections. "element" is selecting the top-most parent container here
      createBackgroundZoomAnimation(element);
    } else if ( element.classList.contains('flsm-parallax--background-fall-away') ) {
      // this is a section containing multiple sub-sections. "element" is selecting the top-most parent container here
      createBackgroundFallAwayAnimation(element);
    } else if ( element.classList.contains('flsm-section--alternating-fixed') ) {
      // this is a section containing multiple sub-sections. "element" is selecting the top-most parent container here
      createAlternatingFixedAnimation(element);
    } else if ( element.classList.contains('flsm-section--fixed-media') ) {
      // this is a section containing multiple sub-sections. "element" is selecting the top-most parent container here
      createFixedMedia(element);
    } else if ( element.classList.contains('flsm-number-counter') ) {
      // flsm-number-counter works best on a span or p tag, since it animates the text immediately inside the element. "element" is selecting that smaller block element here.
      createNumberCounterAnimation(element);
    } else { /* do nothing */ }
  });</pre>
  </code>

  <p>Following that will be our functions containing the JS for each animation. Demos and code are included on separate pages.</p>

  <p>GSAP offers extensive documentation for core, and each of the plugins we've chosen. Start here: <a href="https://gsap.com/docs/v3/">https://gsap.com/docs/v3/</a></p>

  <h4>Plugins Used</h4>
  <ol>
    <li>ScrollTrigger</li>
    <li>Text</li>
  </ol>